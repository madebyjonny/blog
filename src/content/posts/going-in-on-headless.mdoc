---
title: Going in on headless
created_on: 2024-01-02T15:07
summary: >-
  I believe Headless is future. In this article I will be going over the
  benefits and the drawbacks, but hopefully show that going headless won't be as
  scary as you might think!
category: my-thoughts
---
**Prerequisite, this isn’t aimed for sites like my own (which uses markdown files for the posts), but more your mid to large size sites. But to be honest if you're a small business now and aim to grow this may also apply to you.**

What is a headless content management system? From a user's perspective they don’t function much differently, they are still places to organise your content for your website or application. However, instead of a traditional front end, it exposes the content in the form of an API, this could be REST, GraphQL or sometimes both. So you might be thinking this might be a step back, as this means you need another codebase for your front end, and you would be right, but let’s dive into why this is actually a good thing!&nbsp;

Having the front end tightly coupled to your content management system can often be limiting. As in most cases you will have to deploy your whole application or website even if you just want to make a simple change to the front end. You may want to integrate your system into a native application, but if your CMS does not offer an API then it won’t be possible to do. It also means if you did want to migrate away from your content management system at any point it becomes a rewrite as you’re most likely locked into their system.

It becomes difficult to manage design systems as the technologies used by traditional CMS’s don’t support components. Meaning less reusability and standardisation of how parts of the site are constructed usually leading to divergence of styles & code. We all know the pain of not knowing where that CSS style class is used. It usually means full pages have to be created vs having individual components that can work in isolation and can be reused throughout the site layouts giving the content managers much more freedom. This also makes the work for the front end team and designers much more efficient as they can focus on one piece of functionality at a time. This also trickles through the team as QA have less to test at once. Which means less is being deployed at once, enabling confidence with continuous integration rather than having release cycles. (Banking may be an exception here as they will need to have audits done before things are released, but the world of banking is a different can of worms to your average website or application).

So what are some of the drawbacks? It can be complex and on paper it can look intimidating. As you do usually have two codebases, one being the content management system, some open sources examples are Strapi & Payload. You would then have a front end application which would call the api from one of the CMS’s, some examples of front end fFrameworks would be Astro, NextJS & Nuxt. These are described as “meta frameworks” as they run on the server which means they support server side rendering, unlike using React or Vue traditionally which only run on the client. So yes this can be complex, but you could simplify your CMS by using a hosted version such as Prismic, Sanity or Contentful, essentially allowing you to just focus on your front end which does simplify things, but depending on your requirements, may not be suitable.

I can definitely see how this sounds intimidating and selling this to a client might be hard. As to them this will mostly look the same. This is where the developer experience is important as going headless allows the backend & front end tasks to be worked on independently. Meaning more work going from left to right on your Jira board and shipping code without ending up waiting on each other. Having your infrastructure set up like this means reliance on less beefy servers especially if you’re a larger company. As the front end can be cached and if you’re using one of the meta frameworks, they can perform almost like static websites that are hosted on a CDN, which is hard to beat when it comes to performance. Traditional CMS’s can be cached in a similar way but usually this would be an additional thing to add to the framework you are using, where the frameworks I mentioned come with these caching strategies out of the box.&nbsp;

Let’s talk about enterprise… This is a different can of worms. As often enterprise CMS’s come with a kitchen sink approach to features, along with managing the infrastructure for you. But like the same suggests there is a cost associated with it. I believe Sitecore starts in the five figure range and goes up depending on the usage. It is hard for developers to have experience with these systems because of this barrier to entry making it difficult to hire for these systems. The average dev will be learning on the job and the ones that do have experience will be seen as specialists, therefore costing more.&nbsp;

The headless approach to enterprise would be composition, which means adding services that you require that can be managed independently of each other. I know this sounds more complex as well, but most teams won’t have a single person or even a team managing the whole content. If you have marketing pages chances are there will be a person or team whose responsibility it is to manage that, same with e-commerce and then same for the CRM tools. The benefit of composition is you can choose the technologies you want, for example you could use Strapi an open source CMS for content, and then make use of the Shopify Storefront API for the e-commerce side of things. This means you can choose the right service for your business, and even experiment rather than being locked into one you may find you and your team dislike.&nbsp;

I truly believe going headless allows companies to take a pragmatic approach to their business. Empowering teams from design to development to produce consistent and reusable components. This unlocks the ability to ship more confidently without bottlenecks you may find with a traditional CMS.&nbsp;&nbsp;
